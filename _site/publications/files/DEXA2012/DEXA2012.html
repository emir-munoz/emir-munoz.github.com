<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Performance Analysis of Algorithms to Reason about XML Keys.
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</STYLE>
<LINK REL=STYLESHEET type="text/css" HREF="http://river.styx.org/css/river.css">
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -s article.hva performance.tex -->
<!--CUT DEF section 1 -->
<TABLE CLASS="title">
	<TR>
		<TD><H1 CLASS="titlemain">Performance Analysis of Algorithms to Reason about XML Keys.</H1><H3 CLASS="titlerest">Flavio Ferrarotti<SUP>1</SUP> &#XA0;&#XA0;Sven Hartmann<SUP>2</SUP> &#XA0;&#XA0;Sebastian
Link<SUP>3</SUP> &#XA0;&#XA0;Mauricio Marin<SUP>4</SUP> &#XA0;&#XA0;Emir Mu&#XF1;oz<SUP>4,5<A NAME="text1" HREF="#note1">*</A></SUP></H3>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>
<SUP>1</SUP>&#XA0;&#XA0;Victoria University of Wellington &#XA0;&#XA0;<BR>
<SUP>2</SUP>&#XA0;&#XA0;Clausthal University of Technology &#XA0;&#XA0;<BR>
<SUP>3</SUP>&#XA0;&#XA0;The University of Auckland &#XA0;&#XA0;<BR>
<SUP>4</SUP>&#XA0;&#XA0;Yahoo! Research &#XA0;&#XA0;<BR>
<SUP>5</SUP>&#XA0;&#XA0;University of Santiago de Chile<BR>

Contact E-mail: Flavio.Ferrarotti@vuw.ac.nz </P>
		</TD>
	</TR>
</TABLE><BLOCKQUOTE CLASS="abstract"><B>Abstract: </B>
Keys are fundamental for database management, independently of the particular
data model used. 
In particular, several notions of XML
keys have been proposed over the last decade, and their expressiveness and computational properties
have been analyzed in theory. In practice, however, expressive notions of XML
keys with good reasoning capabilities have been widely ignored. In this paper
we present an efficient implementation of an algorithm that decides the implication problem
for a tractable class of XML keys. We also evaluate the performance of the
proposed algorithm, demonstrating that
reasoning about expressive notions of XML keys can be done efficiently in
practice and scales well. Our work indicates that XML keys as
those studied here have great potential for diverse areas such as schema design, 
query optimization, storage and updates, data exchange and integration.
To exemplify this potential, we use the algorithm to calculate
non-redundant covers for sets of XML keys, and show that these covers can significantly
reduce the number of XML keys against which XML documents must be validated.
This can result in enormous time savings.</BLOCKQUOTE><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Introduction</H2><!--SEC END --><P><A NAME="sec1:intro"></A>
The increasing popularity of XML [<A HREF="#xml:2006">1</A>] for persistent data storage and
data processing has triggered the demand for efficient algorithms for managing
XML data. Both industry and academia have long since recognized the importance
of keys in XML data management. Over the last decade, several notions of XML
keys have been proposed and discussed in the database community (see
[<A HREF="#Hartmann:2008a">2</A>] for a brief overview). The most influential proposal is
due to Buneman et al.&#XA0;[<A HREF="#Buneman:2002">3</A>, <A HREF="#Buneman:2003">4</A>] who defined keys on the
basis of an XML tree model similar to the one suggested by DOM&#XA0;[<A HREF="#dom:1998">5</A>]
and XPath [<A HREF="#xpath:1999">6</A>]. While Buneman et al. studied keys as a concept
orthogonal to schema specification (such as DTD or XSD), their proposal has
been adopted by the W3C for the XML Schema standard [<A HREF="#xmlschema:2004">7</A>]
subject to some minor, though essential modifications (see [<A HREF="#arenas:2002">8</A>]
for a discussion). Today, all major XML-enabled DBMS, XML parsers and editors
(such as XMLSpy) support keys.</P>

<P>
<I>Example&#XA0;1</I>.
Figure&#XA0;<A HREF="#xml-data">1</A> shows an XML tree, in which nodes are annotated by their type: <EM>E</EM> for element nodes,
<EM>A</EM> for attribute nodes, and <EM>S</EM> for text nodes.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<A NAME="xml-data"><IMG SRC="images/figure-1.png"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 1: An XML tree representing an XML document.</TD></TR>
</TABLE></DIV>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>
For the data represented in Figure&#XA0;<A HREF="#xml-data">1</A> we have the following keys: (a)&#XA0;A <EM>project</EM> node is identified by <EM>pname</EM>, no matter where the <EM>project</EM> node appears in the document. (b)&#XA0;A <EM>team</EM> node can be identified by <EM>tname</EM> relatively to a <EM>project</EM> node. (c)&#XA0;Within any given subtree rooted at <EM>team</EM>, an <EM>employee</EM> node is identified by <EM>name</EM>. The first key is an example of an <EM>absolute key</EM> since it must hold globally throughout the entire tree. The last two are examples of <EM>relative keys</EM> since they hold locally within some subtrees. Note that a given team of employees can work on several projects and thus a <EM>team</EM> node cannot be identified in the entire tree by its <EM>tname</EM>. However, it holds locally within each subtree rooted at a <EM>project</EM> node. Similarly, a given employee can work on different teams and thus cannot be identified in the entire tree by its <EM>name</EM>.
</P><P>For relational data, keys have been widely used to improve the performance of many perennial tasks in database management, ranging from consistency checking to query answering. The hope is that keys will turn out to be equally beneficial for XML. One of the most fundamental questions on keys is that of logical implication, that is, deciding if a new key holds given a set of known keys. Among other things, this is important for minimizing the cost of validating that an XML document satisfies a set of keys gathered as business rules during requirements engineering.</P>

<P>
<I>Example&#XA0;2</I>.
Suppose, the database designer has already specified the keys&#XA0;(a), (b) and (c). Now she considers a further key&#XA0;(d) which expresses that a <EM>project</EM> node can be identified by its child nodes <EM>pname</EM> and <EM>team</EM>. By key&#XA0;(a) one already knows that a <EM>project</EM> node can also be identified by just its <EM>pname</EM>. It is easy to see that&#XA0;(a) actually implies&#XA0;(d), in the sense that every XML tree that satisfies&#XA0;(a) also satisfies&#XA0;(d). Thus, checking whether an XML tree <I>T</I> satisfies&#XA0;(a) is equivalent to checking whether <I>T</I> satisfies&#XA0;(a) and&#XA0;(d). We like to emphasize that <EM>project</EM> nodes have complex content. Thus, checking whether two <EM>project</EM> nodes in <I>T</I> violate (d) is quite costly in terms of time, since it involves testing whether the subtrees rooted at their <EM>team</EM> nodes are isomorphic to one another with the identity on string values. In contrast, checking whether two <EM>project</EM> nodes violate (a) only involves checking equality on text of their respective <EM>pname</EM> attribute nodes.
</P>

<P>
<I>Example&#XA0;3</I>. No less important, the implication of XML keys is of interest for semantically rich data exchange. Suppose, the company wants to share part of their project data with a business partner. For that they generate a view over the XML tree <I>T</I> but skip the <EM>lname</EM> nodes for the sake of privacy. Thus, key&#XA0;(c) is no longer meaningful. To provide the business partner with relevant semantic information it should be checked whether the specified keys allow one to conclude a further key stating that an <EM>employee</EM> node is identified by their surviving descendant nodes <EM>fname</EM> and <EM>role</EM> within any given <EM>team</EM> subtree.
</P>

<P>The definition of keys adopted by the W3C for XML Schema [<A HREF="#xmlschema:2004">7</A>] is currently the industry standard for specifying keys. However, Arenas et al.&#XA0;[<A HREF="#arenas:2002">8</A>] have shown the computational intractability of the associated consistency problem, i.e., the question whether there exists an XML document that conforms to a given XSD and satisfies the specified keys. A further issue pointed out by Buneman et al. [<A HREF="#Buneman:2002">3</A>] is the fact that XML Schema restricts value equality to string-valued data items. But there are cases in which keys are not so restricted (see Section&#XA0;7.1 of [<A HREF="#Buneman:2002">3</A>] for discussion). In particular, keys&#XA0;(c) and&#XA0;(d) in our examples utilize a less restricted notion of equality, since they require to test equality between <EM>name</EM> nodes and <EM>team</EM> nodes, respectively, none of which are string-valued. On the other hand, the expressiveness and computational properties of XML keys with good reasoning capabilities have been deeply studied from a theoretical perspective [<A HREF="#Buneman:2002">3</A>, <A HREF="#Buneman:2003">4</A>, <A HREF="#Hartmann:2009">9</A>, <A HREF="#Hartmann:2009b">10</A>, <A HREF="#Ferrarotti:2010">11</A>]. In practice, however, expressive yet tractable notions of XML keys have been ignored so far.</P><P>Aiming to fill this gap between theory and practice, we initiate in this work an empirical study of an expressive XML key fragment, namely the fragment of XML keys with nonempty sets of simple key paths. As shown in [<A HREF="#Buneman:2003">4</A>, <A HREF="#Hartmann:2009">9</A>], automated reasoning about this XML key fragment can be done efficiently, in theoretical terms. Our work confirms this fact in practice. Incidentally, note that all the examples of XML keys described above belong to this fragment.</P><P>In this paper, we describe an efficient implementation of an algorithm that
decides the implication problem for an expressive fragment of XML keys
and thoroughly evaluate its performance. Our
performance tests give first empirical evidence that reasoning about
expressive notions of XML keys is practically efficient and scales well. Our
work indicates that XML keys have great potential for database management
tasks similar to their counterparts for relational data.</P><P>Within our algorithm we exploit non-redundant covers for sets of XML keys. A
set &#X3A3; of keys is non-redundant if there is no proper subset
&#X3A3;<SUP>&#X2032;</SUP> of &#X3A3; such that the set of all keys implied by
&#X3A3;<SUP>&#X2032;</SUP> coincides with the set of all keys implied by &#X3A3;. Thus,
considering such covers has the potential to reduce significantly the number
of keys against which an XML document must be validated. This can result in
enormous time savings. Our experiments show that the time to compute a cover
for a given set of keys is just a small fraction of the average time needed to
validate an XML document against a single key. Surprisingly, even though
several algorithms that validate XML documents against sets of certain XML
keys have been proposed and tested with promising results (see e.g.&#XA0;
[<A HREF="#Chen:2002">12</A>, <A HREF="#Abrao:2004">13</A>, <A HREF="#Liu:2005">14</A>]), none of them makes use of the reasoning capabilities of XML keys as proposed in our work.</P><P>The paper is organized as follows. We recall basic notions in Section&#XA0;2,
including the central notion of XML key which is used through this work. 
In Section&#XA0;3, we present the algorithm for deciding XML key implication, and describe an
implementation thereof in Section&#XA0;4. In Section&#XA0;5, we discuss how this
implementation can be reused to speed up the validation of XML documents
against sets of XML keys. Section&#XA0;6 summarizes experimental results obtained
from applying our implementations to publicly available XML data, including
DBLP, the SIGMOD Record, and the Mondial database. We conclude the paper in
Section&#XA0;7 with final remarks.</P><!--TOC section Keys for XML-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;Keys for XML</H2><!--SEC END --><P>
<A NAME="sec1:preliminaries"></A></P><P>
We use the common representation of XML data as ordered, node-labelled trees.
Thus, an <EM>XML tree</EM> is a 6-tuple <I>T</I>=(<I>V</I>,<I>lab</I>,<I>ele</I>,<I>att</I>,<I>val</I>,<I>r</I>) where <I>V</I> is a
set of nodes, and <I>lab</I> is a mapping <I>V</I>&#X2192;<FONT COLOR=red><I>L</I></FONT> = <B>E</B>&#X222A;<B>A</B>&#X222A;{<I>S</I>}
assigning a label to every node in <I>V</I>. A node <I>v</I>&#X2208; <I>V</I> is an <EM>element node</EM> if
<I>lab</I>(<I>v</I>)&#X2208;<B>E</B>, an <EM>attribute node</EM> if <I>lab</I>(<I>v</I>)&#X2208;<B>A</B>, and
a <EM>text node</EM> if <I>lab</I>(<I>v</I>)=<I>S</I>. Here <B>E</B>&#X222A;<B>A</B>&#X222A;{<I>S</I>}
form a partition of <FONT COLOR=red><I>L</I></FONT>. Moreover, <EM>ele</EM> and <EM>att</EM> are
partial mappings defining the edge relation of <I>T</I>: for any node <I>v</I>&#X2208; <I>V</I>, if
<I>v</I> is an element node, then <I>ele</I>(<I>v</I>) is a list of element and text nodes in
<I>V</I> and <I>att</I>(<I>v</I>) is a set of attribute nodes in <I>V</I>. The partial mapping
<EM>val</EM> assigns a string to each attribute and text node. Finally, <I>r</I> is the unique and distinguished
root node. 

The XML keys studied in this work are defined using the path
language <I>PL</I> consisting of expressions given by the
following grammar:
<I>Q</I> &#X2192; &#X2113; &#XA0; | &#XA0; &#X3B5; &#XA0; |
&#XA0; <I>Q</I>.<I>Q</I> &#XA0; | 
&#XA0; _<SUP>*</SUP>. 
Here &#X2113; &#X2208; <FONT COLOR=red><I>L</I></FONT> is any label, &#X3B5; denotes the empty path
expression, &#X201C;.&#X201D; denotes the concatenation of two path expressions, 
and &#X201C;_<SUP>*</SUP>&#X201D; denotes the 
<EM>variable length &#X201C;don&#X2019;t care&#X201D;</EM> wildcard. 
Let <I>Q</I> be a word from <I>PL</I>. A path <I>v</I><SUB>1</SUB>, &#X2026;, <I>v</I><SUB><I>n</I></SUB> in
an XML tree <I>T</I> is called a <I>Q</I>-path if <I>lab</I>(<I>v</I><SUB>1</SUB>). &#X22EF; .<I>lab</I>(<I>v</I><SUB><I>n</I></SUB>) can be 
obtained from <I>Q</I> by replacing variable length wildcards in <I>Q</I> by words from
<I>PL</I>. 
For a node <I>v</I>&#X2208; <I>V</I>, <I>v</I>[[<I>Q</I>]] denotes the set of nodes in <I>T</I> that are reachable from <I>v</I>
following any <I>Q</I>-path.
We use [[<I>Q</I>]] as an abbreviation for <I>r</I>[[<I>Q</I>]] where <I>r</I> is the root node of <I>T</I>.
We denote as <I>PL</I><SUB><I>s</I></SUB> the subset of <I>PL</I> expressions containing all words over
the alphabet <FONT COLOR=red> <I>L</I></FONT>, i.e., we do not allow wildcards in <I>PL</I><SUB><I>s</I></SUB> expressions.
<I>Q</I> &#X2208; <I>PL</I> is <EM>valid</EM>
if it does not have labels &#X2113;&#X2208;<B>A</B> or &#X2113;=<I>S</I> in a
position other than the last one. 

We define formally the concept of XML key following&#XA0;[<A HREF="#Buneman:2003">4</A>]. For
that, we need the concept value equality. Two nodes <I>u</I>,<I>v</I>&#X2208; <I>V</I> are <EM>value&#XA0;equal</EM>, denoted by <I>u</I>=<SUB><I>v</I></SUB><I>v</I>, iff the
subtrees rooted at <I>u</I> and <I>v</I> are isomorphic by an isomorphism that is the
identity on string values. 
As an example, the
third and fifth <EM>employee</EM>-nodes are not value equal while their
respective child nodes labeled as <EM>name</EM> are.</P><P>
	
<B>Definition&#XA0;1</B>.
An XML key &#X3D5; in the class <FONT COLOR=red><I>K</I></FONT> is an expression
of the form (<I>Q</I><SUB>&#X3D5;</SUB>,(<I>Q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>,{<I>P</I><SUB>1</SUB><SUP>&#X3D5;</SUP>,&#X2026;,<I>P</I><SUB><I>k</I><SUB>&#X3D5;</SUB></SUB><SUP>&#X3D5;</SUP>}))
where <I>k</I><SUB>&#X3D5;</SUB>&#X2265; 1, <I>Q</I><SUB>&#X3D5;</SUB> and <I>Q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> are <I>PL</I>
expressions, and for all <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3D5;</SUB>, <I>P</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP> is a <I>PL</I><SUB><I>s</I></SUB>
expressions such that <I>Q</I><SUB>&#X3D5;</SUB>.<I>Q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>.<I>P</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP> is a valid <I>PL</I>
expression.
An XML tree <I>T</I> satisfies the key (<I>Q</I>,(<I>Q</I><SUP>&#X2032;</SUP>,{<I>P</I><SUB>1</SUB>,&#X2026;,<I>P</I><SUB><I>k</I></SUB>})) if and
only if for every node <I>q</I>&#X2208; [[<I>Q</I>]] and all nodes <I>q</I><SUB>1</SUB><SUP>&#X2032;</SUP>,<I>q</I><SUB>2</SUB><SUP>&#X2032;</SUP>&#X2208;
<I>q</I>[[<I>Q</I><SUP>&#X2032;</SUP>]] such that there are nodes <I>x</I><SUB><I>i</I></SUB>&#X2208; <I>q</I><SUB>1</SUB><SUP>&#X2032;</SUP>[[<I>Q</I><SUB><I>i</I></SUB>]], <I>y</I><SUB><I>i</I></SUB>&#X2208;
<I>q</I><SUB>2</SUB><SUP>&#X2032;</SUP>[[<I>P</I><SUB><I>i</I></SUB>]] with <I>x</I><SUB><I>i</I></SUB>=<SUB><I>v</I></SUB><I>y</I><SUB><I>i</I></SUB> for all <I>i</I>=1,&#X2026;,<I>k</I>, then
<I>q</I><SUB>1</SUB><SUP>&#X2032;</SUP>=<I>q</I><SUB>2</SUB><SUP>&#X2032;</SUP>.
Therefore, <I>Q</I><SUB>&#X3D5;</SUB> is called the <EM>context path</EM>,
<I>Q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> is
called the <EM>target path</EM>, and <I>P</I><SUB>1</SUB><SUP>&#X3D5;</SUP>,&#X2026;,<I>P</I><SUB><I>k</I><SUB>&#X3D5;</SUB></SUB><SUP>&#X3D5;</SUP> are called the <EM>key
paths</EM> of &#X3D5;.
</P><P>In particular, the four keys described informally in the introduction,
belong to this class and can be expressed formally as follows: (a) (&#X3B5;, (<I><I>project</I></I>, {<I><I>pname</I></I>}));
(b) (<I><I>project</I></I>, (<I><I>team</I></I> {<I><I>tname</I></I>})); (c) (_<SUP>*</SUP>.<I><I>team</I></I>, (<I><I>employee</I></I>,{<I><I>name</I></I>})); 
(d) (&#X3B5;, (<I><I>project</I></I>, {<I><I>pname</I></I>,<I><I>team</I></I>})).</P><!--TOC section Deciding XML Key Implication-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">3</A>&#XA0;&#XA0;Deciding XML Key Implication</H2><!--SEC END --><P>
<A NAME="sec1:implication"></A>

Let &#X3A3;&#X222A;{&#X3D5;} be a finite set of XML keys in a class
<FONT COLOR=red><I>C</I></FONT>. We say that &#X3A3;
<EM>implies</EM> &#X3D5;, denoted by &#X3A3;&#X22A8;&#X3D5;, if and only if every finite XML tree <I>T</I> that satisfies all
&#X3C3;&#X2208;&#X3A3; also satisfies &#X3D5;. The <EM>implication
problem</EM> for <FONT COLOR=red><I>C</I></FONT> is to decide, given any finite set
&#X3A3;&#X222A;{&#X3D5;} of keys in <FONT COLOR=red><I>C</I></FONT>, whether
&#X3A3;&#X22A8;&#X3D5;.
</P><P>A finite axiomatization for the implication of keys in the class 
of XML keys with nonempty sets of simple key paths <FONT COLOR=red><I>K</I></FONT>, was established
in [<A HREF="#Hartmann:2009">9</A>]. 
The completeness proof of this axiomatization is based on a characterization
of key implication in terms of the reachability problem for fixed nodes in a
suitable digraph. This characterization, 
together with the efficient evaluation
of Core XPath [<A HREF="#gottlob:2005">15</A>], 
resulted in a compact
algorithm to decide XML key implication in time quadratic in the size of
the input key. This algorithm, which is described next, forms the basis for our
implementation. We need the following technical concepts.<BR><BR>


<B>Mini-trees and Witness Graphs</B>.
Let &#X3A3;&#X222A;{&#X3D5;} be a finite set of keys in
<FONT COLOR=red><I>K</I></FONT>. Let
<FONT COLOR=red><I>L</I></FONT><SUB>&#X3A3;,&#X3D5;</SUB> denote the set of all labels &#X2113;&#X2208;<FONT COLOR=red><I>L</I></FONT>
that occur in path expressions of keys in &#X3A3;&#X222A;{&#X3D5;}, and fix a
label &#X2113;<SUB>0</SUB>&#X2208;<B>E</B>&#X2212;<FONT COLOR=red><I>L</I></FONT><SUB>&#X3A3;,&#X3D5;</SUB>. Let
<I>O</I><SUB>&#X3D5;</SUB> and <I>O</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> be the <I>PL</I><SUB><I>s</I></SUB> expressions obtained from the
<I>PL</I> expressions <I>Q</I><SUB>&#X3D5;</SUB> and <I>Q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>, respectively, by
replacing each wildcard &#X201C;_<SUP>*</SUP>&#X201D; by &#X2113;<SUB>0</SUB>.
Let <I>p</I> be an <I>O</I><SUB>&#X3D5;</SUB>-path from a node <I>r</I><SUB>&#X3D5;</SUB> to a node <I>q</I><SUB>&#X3D5;</SUB>,
let <I>p</I><SUP>&#X2032;</SUP> be an <I>O</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>-path from a node <I>r</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> to
a node <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> and, for each <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3D5;</SUB>, let <I>p</I><SUB><I>i</I></SUB> be
a <I>P</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP>-path from a node <I>r</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP> to a node <I>x</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP>, such
that the paths <I>p</I>,<I>p</I><SUP>&#X2032;</SUP>,<I>p</I><SUB>1</SUB>,&#X2026;,<I>p</I><SUB><I>k</I><SUB>&#X3D5;</SUB></SUB> are mutually
node-disjoint. From the paths <I>p</I>,<I>p</I><SUP>&#X2032;</SUP>,<I>p</I><SUB>1</SUB>,&#X2026;,<I>p</I><SUB><I>k</I><SUB>&#X3D5;</SUB></SUB> we obtain
the <EM>mini-tree</EM> <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> by identifying the node
<I>r</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> with <I>q</I><SUB>&#X3D5;</SUB>, and by identifying each of the nodes
<I>r</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP> with <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>.
The <EM>marking</EM> of the mini-tree
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> is a subset <FONT COLOR=red><I>M</I></FONT> of the node set of
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>: if for all <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3D5;</SUB> we have
<I>P</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP>&#X2260;&#X3B5;, then <FONT COLOR=red><I>M</I></FONT> consists of the leaves of
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>, and otherwise <FONT COLOR=red><I>M</I></FONT> consists of all descendant
nodes of <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>. 
<A NAME="ex-min-tree"></A><BR><BR>

<I>Example&#XA0;4.</I>
Let &#X3A3; = {&#X3C3;<SUB>1</SUB>, &#X3C3;<SUB>2</SUB>} where &#X3C3;<SUB>1</SUB> and &#X3C3;<SUB>2</SUB> are the
XML keys (&#X3B5;,(<I><I>public</I></I>._<SUP>*</SUP>, {<I><I>project</I></I>.<I><I>pname</I></I>.<I>S</I>, <I>project</I>.<I>year</I>.<I>S</I>})) and
(<I><I>public</I></I>,(_<SUP>*</SUP>.<I><I>project</I></I>,{<I>pname</I>.S,
<I>year</I>.<I>S</I>})), respectively. Let 
&#X3D5; = (&#X3B5;, (<I>public</I>._<SUP>*</SUP>.<I>project</I>,
{<I>pname</I>.<I>S</I>, <I>year</I>.<I>S</I>})).
The construction of the mini-tree <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> is schematized in
Figure&#XA0;<A HREF="#fig_mini_tree">2(a)</A>&#XA0;. 
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<A NAME="fig_mini_tree"></A><IMG SRC="images/figure-2.png">
<DIV CLASS="caption">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2: Mini-tree, Witness-graph and Adjacency list.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>

The mini-trees are used in the algorithm as a base to calculate the impact of a key in &#X3A3; on a possible
counter-example tree for the implication of &#X3D5; by &#X3A3;. To
distinguish keys that have an impact from those that do not, the following
notion of <EM>applicability</EM> is needed. 
Let <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> be the mini-tree of the key &#X3D5; with respect to
&#X3A3;, and let <FONT COLOR=red><I>M</I></FONT> be its marking. A key &#X3C3; is said to be
<EM>applicable</EM> to &#X3D5; if and only if there are nodes
<I>w</I><SUB>&#X3C3;</SUB>&#X2208;[[<I>Q</I><SUB>&#X3C3;</SUB>]] and <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>&#X2208;
<I>w</I><SUB>&#X3C3;</SUB>[[<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> such that
<I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>[[<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>]]&#X2229;<FONT COLOR=red><I>M</I></FONT>&#X2260;&#X2205; for all
<I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3C3;</SUB>. We say that <I>w</I><SUB>&#X3C3;</SUB> and <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>
<EM>witness</EM> the applicability of &#X3C3; to &#X3D5;. </P><P>We define the <EM>witness graph</EM> <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> as the node-labeled
digraph obtained from <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> by inserting additional edges: for
each key &#X3C3;&#X2208;&#X3A3; that is applicable to &#X3D5; and for each pair
of nodes <I>w</I><SUB>&#X3C3;</SUB>&#X2208; [[<I>Q</I><SUB>&#X3C3;</SUB>]] and <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>&#X2208;
<I>w</I><SUB>&#X3C3;</SUB>[[<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] that witness the applicability of &#X3C3; to
&#X3D5;, <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> contains the directed edge
(<I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>,<I>w</I><SUB>&#X3C3;</SUB>) from <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> to <I>w</I><SUB>&#X3C3;</SUB>.
<A NAME="ex-implication1"></A><BR><BR>

<I>Example&#XA0;5.</I>
Let &#X3A3; and &#X3D5; be as in
Example&#XA0;<A HREF="#ex-min-tree">3</A>. Both keys in &#X3A3; are applicable to &#X3D5;.
The witness graph <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> is shown in 
Figure&#XA0;<A HREF="#fig_mini_tree">2(b)</A>&#XA0;. It contains a witness edge from
<EM>national</EM> to <EM>db</EM> that arises from &#X3C3;<SUB>1</SUB> and a witness edge
from <EM>project</EM> to <EM>public</EM> that arises from &#X3C3;<SUB>2</SUB>.
</P><P><BR>
	
<B>The algorithm</B>. Algorithm&#XA0;<A HREF="#alg:implication">1</A> decides XML key
implication. Its correctness is an immediate consequence of
Theorem&#XA0;<A HREF="#theorem">1</A>. <BR><BR>

<B>Theorem&#XA0;1.</B>
<EM>(</EM><EM>[</EM><A HREF="#Hartmann:2009"><EM>9</EM></A><EM>]</EM><EM>)</EM><A NAME="theorem"></A> Let &#X3A3; &#X222A; {&#X3D5;} be a finite set of keys in
the class <FONT COLOR=red><I>K</I></FONT>. We have &#X3A3; &#X22A8; &#X3D5; if and
only if <I>q</I><SUB>&#X3D5;</SUB> is reachable from <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in
<I>G</I><SUB>&#X3A3;,&#X3D5;</SUB>.<BR><BR>


<A NAME="alg:implication"><IMG SRC="images/algo-1.png"></A><BR><BR>
<!--
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Mini-tree corresponding to a non-implied key.</TD></TR>
</TABLE></DIV>
-->
<!--
(XML key implication in <FONT COLOR=red><I>K</I></FONT>)
<A NAME="alg:implication"></A>
[1]

finite set of XML keys &#X3A3; &#X222A; {&#X3D5;} in
<FONT COLOR=red><I>K</I></FONT>
yes, if &#X3A3; &#X22A8; &#X3D5;; no, otherwise
Construct <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> for &#X3A3; and &#X3D5;;
<B>if</B> <I>q</I><SUB>&#X3D5;</SUB> is reachable from <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in <I>G</I> <B>then</B> <B>return</B> yes;<BR>
<B>else</B> <B>return</B> no; <B>end if</B>
-->


</P><!--TOC section An Efficient Implementation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">4</A>&#XA0;&#XA0;An Efficient Implementation</H2><!--SEC END --><P>
<A NAME="sec1:implication-implementation"></A></P><P>In this section we discuss our implementation of
Algorithm&#XA0;<A HREF="#alg:implication">3</A> and analyze its theoretical complexity. 
The implementation was developed in C++ using <I>gcc</I> version 4.4.3 from
the GNU compiler collection. </P><P>
<B>Data Structures</B>. We need data structures suitable to represent
mini-trees and witness-graphs. The obvious candidates are adjacency matrices
and adjacency lists [<A HREF="#Aho:1983">16</A>]. 
Since the algorithm does not require frequent 
determination of edge existence, we choose the latter in order
to minimize the memory requirements. 
In our implementation, a mini-tree
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> is represented by using a list <I>L</I> of length
<I>n</I>=|<I>V</I>| where <I>V</I> is the vertex set of <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>. Each element
<I>e</I><SUB><I>i</I></SUB> &#X2208; <I>L</I> is represented by an object of type <EM>vertexEle</EM> that 
has a pointer to the adjacency list of the
<I>i</I>-th vertex <I>v</I><SUB><I>i</I></SUB> in some fixed enumeration of the vertices in <I>V</I>, a
pointer to the data component of the vertex <I>v</I><SUB><I>i</I></SUB>, and a pointer to the next
element <I>e</I><SUB><I>i</I>+1</SUB> in the list. In turn, the data component of a vertex <I>v</I><SUB><I>i</I></SUB> is 
represented by an object of type <EM>nodeEle</EM>, and an element in the
adjacency list of a vertex <I>v</I><SUB><I>i</I></SUB> is represented by an object of type
<EM>edgeEle</EM>. An object of type
<EM>nodeEle</EM> has an <EM>id</EM> component that uniquely identifies <I>v</I><SUB><I>i</I></SUB>, a
<EM>label</EM> component with the label of <I>v</I><SUB><I>i</I></SUB>, a flag <EM>visited</EM>, 
and a <EM>type</EM> component
with the type <I>E</I> (element), <I>A</I> (attribute) or <I>S</I> (PCDATA) of <I>v</I><SUB><I>i</I></SUB>. 
An object of type <EM>edgeEle</EM> has a pointer to an object of type <EM>vertexEle</EM>
and a pointer to the next object of type <EM>edgeEle</EM> in the adjacency list. 
Witness graphs are represented likewise. 
Figure&#XA0;<A HREF="#fig:minitree-b">2(b)</A> 
shows a witness graph and Figure&#XA0;<A HREF="#fig:minitree-c">2(c)</A> a corresponding
representation using adjacency lists. </P><P>

<B>The Implementation</B>. We implemented Step 1 of Algorithm&#XA0;<A HREF="#alg:implication">1</A>, using the following
strategy:
</P><OL CLASS="enumerate" type="i"><LI CLASS="li-enumerate">
Construct <I>T</I><SUB>&#X3A3;, &#X3D5;</SUB>;
</LI><LI CLASS="li-enumerate">Determine the marking of <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>;
</LI><LI CLASS="li-enumerate">For each &#X3C3; &#X2208; &#X3A3;, add the edge (<I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>,<I>w</I><SUB>&#X3C3;</SUB>)
to <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> whenever <I>w</I><SUB>&#X3C3;</SUB> and <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> witness the
applicability of &#X3C3; to &#X3D5;. 
</LI></OL><P> 
Substep&#XA0;(i) involves constructing the mini-tree
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> using the data structures defined at the
beginning of this section. Note that we can find a label &#X2113;<SUB>0</SUB> that is not among the labels
used in the XML keys in &#X3A3; &#X222A; {&#X3D5;} in time &#X2211;<SUB>&#X3C3;<SUB><I>i</I></SUB> &#X2208; &#X3A3;</SUB> |&#X3C3;<SUB><I>i</I></SUB>| +
|&#X3D5;|, where |&#X3C3;<SUB><I>i</I></SUB>| and |&#X3D5;| denote the sum of the lengths of all path
expressions in &#X3C3;<SUB><I>i</I></SUB> and &#X3D5;, respectively. 
Once we have got a suitable label, &#X2113;<SUB>0</SUB>, <I>T</I><SUB>&#X3A3;, &#X3D5;</SUB> can be built in time <FONT COLOR=red>
<I>O</I></FONT>(|&#X3D5;|), since the mini-tree <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> has only |&#X3D5;|+1 nodes. 

Regarding Substep&#XA0;(ii), if <I>P</I><SUB><I>i</I></SUB><SUP>&#X3D5;</SUP>&#X2260; &#X3B5; we can determine the marking of the
mini-tree <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> by simply traversing the list <I>L</I>
marking the nodes whose adjacency list is empty. Note that those nodes
correspond to leaves in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>. Otherwise, we mark all 
nodes in the adjacency list of the element <I>e</I><SUB><I>i</I></SUB> in <I>L</I> that represents
<I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>, and recursively mark all descendants of those nodes. 
This step takes <FONT COLOR=red> <I>O</I></FONT>(|&#X3D5;|) time.</P><P>In principle, Substep&#XA0;(iii) requires, for each &#X3C3; &#X2208; &#X3A3;, 
to evaluate <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>[[<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>]] for <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3C3;</SUB>, 
for all <I>w</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>&#X2208; <I>w</I><SUB>&#X3C3;</SUB>[[<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] and all
<I>w</I><SUB>&#X3C3;</SUB>&#X2208; [[<I>Q</I><SUB>&#X3C3;</SUB>]]. However, we do not need to determine
<EM>all</EM> witness edges (<I>w</I><SUP>&#X2032;</SUP>,<I>w</I>) to decide whether <I>q</I><SUB>&#X3D5;</SUB> is
reachable from <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in the witness graph <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB>.
Let <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> be the set of all nodes <I>w</I><SUP>&#X2032;</SUP> in
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> for which there exists some node <I>w</I> in
<I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> such that <I>w</I> and <I>w</I><SUP>&#X2032;</SUP> witness the applicability of
&#X3C3; to &#X3D5;. Further, for each <I>w</I><SUP>&#X2032;</SUP>&#X2208; <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>, let
<I>W</I><SUB>&#X3C3;</SUB>(<I>w</I><SUP>&#X2032;</SUP>) be the set of all nodes <I>w</I> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> such
that <I>w</I> and <I>w</I><SUP>&#X2032;</SUP> witness the applicability of &#X3C3; to &#X3D5;.
The witness edges are just the pairs (<I>w</I><SUP>&#X2032;</SUP>,<I>w</I>) with <I>w</I><SUP>&#X2032;</SUP>&#X2208;
<I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> and <I>w</I>&#X2208; <I>W</I><SUB>&#X3C3;</SUB>(<I>w</I><SUP>&#X2032;</SUP>). 
As shown in [<A HREF="#Hartmann:2009">9</A>], it is not necessary
to determine the entire set <I>W</I><SUB>&#X3C3;</SUB>(<I>w</I><SUP>&#X2032;</SUP>) for each <I>w</I><SUP>&#X2032;</SUP>&#X2208;
<I>W</I><SUB>&#X3C3;</SUB>. We can actually restrict ourselves to 
the top-most ancestor of <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> that 
belongs to <I>W</I><SUB>&#X3C3;</SUB>(<I>w</I><SUP>&#X2032;</SUP>), which we denote by <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>)
(if it exists).</P><P>So, we need first to determine <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>, and then, for each
<I>w</I><SUP>&#X2032;</SUP>&#X2208; <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>, we need to determine <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) (if it exists). 
By definition, <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> consists of all nodes
<I>w</I><SUP>&#X2032;</SUP>&#X2208;[[<I>Q</I><SUB>&#X3C3;</SUB>.<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> such that,
for each <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3C3;</SUB>, there is a marked node in
<I>w</I><SUP>&#X2032;</SUP>[[<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>]]. Since a query of the form <I>v</I>[[<I>Q</I>]] is a Core XPath query 
and can be evaluated on a node-labelled tree <I>T</I> in
<FONT COLOR=red><I>O</I></FONT>(|<I>T</I>|&#XD7;|<I>Q</I>|) time, it follows that [[<I>Q</I><SUB>&#X3C3;</SUB>.<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] can be
evaluated in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> in <FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7;|<I>Q</I><SUB>&#X3C3;</SUB>.<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>|)
time. Next, fix some <I>i</I>&#X2208;{1,&#X2026;,<I>k</I><SUB>&#X3C3;</SUB>}. Let <I>v</I> be a marked node,
and let <I>u</I> denote the ancestor of <I>v</I> that resides |<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>|
levels atop of <I>v</I> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> (if it exists). We can then check
whether <I>v</I>&#X2208; <I>u</I>[[<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>]], that is, whether the unique path from <I>u</I> to
<I>v</I> is a <I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>-path. This can be done in <FONT COLOR=red><I>O</I></FONT>(min{|<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>|,|&#X3D5;|}) time, since <I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP> is
a <I>PL</I><SUB><I>s</I></SUB> expression. By inspecting all nodes <I>v</I>&#X2208;<FONT COLOR=red><I>M</I></FONT>, we obtain the
set <I>U</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP> of all nodes <I>u</I> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> for which
<I>u</I>[[<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>]]&#X2229;<FONT COLOR=red><I>M</I></FONT>&#X2260;&#X2205;. Overall, this takes <FONT COLOR=red><I>O</I></FONT>(|<FONT COLOR=red><I>M</I></FONT>|&#XD7;|<I>P</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>|}) time. Since <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> is
the intersection of [[<I>Q</I><SUB>&#X3C3;</SUB>.<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>]] with the sets
<I>U</I><SUB><I>i</I></SUB><SUP>&#X3C3;</SUP>, <I>i</I>=1,&#X2026;,<I>k</I><SUB>&#X3C3;</SUB>, we get that <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> can be
determined in <FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7;|&#X3C3;|) time.
Regarding <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>), note that if <I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> is a
<I>PL</I><SUB><I>s</I></SUB> expression, then <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) is the node
|<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>| levels atop of <I>w</I><SUP>&#X2032;</SUP> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>.
Otherwise <I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> contains a _<SUP>*</SUP>, and thus has the form
<I>A</I>._<SUP>*</SUP>.<I>B</I> where <I>A</I> is a <I>PL</I><SUB><I>s</I></SUB> expression and <I>B</I> is a <I>PL</I>
expression. In this case, as shown in [<A HREF="#Hartmann:2009">9</A>],
<I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) is the top-most ancestor <I>w</I> of <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>
in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB> that belongs to [[<I>Q</I><SUB>&#X3C3;</SUB>]] and for which
<I>w</I>[[<I>A</I>]] is non-empty. In particular, <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) is independent 
from the choice of <I>w</I><SUP>&#X2032;</SUP> in <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>. Thus, we propose 
Algorithm&#XA0;<A HREF="#alg:wprima">2</A> to determine <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) for a given
node <I>w</I><SUP>&#X2032;</SUP>.</P><BR>


<!--
<P>[t]

(Determine <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>))

<A NAME="alg:wprima"></A>
[1]

a mini-tree <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>, a set <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>, and a node
<I>w</I><SUP>&#X2032;</SUP>&#X2208; <I>W</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>.
<I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>)
<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP> is a <I>PL</I><SUB><I>s</I></SUB> expression
The node |<I>Q</I><SUB>&#X3C3;</SUB><SUP>&#X2032;</SUP>| levels atop of <I>w</I><SUP>&#X2032;</SUP> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>

Determine the set [[<I>Q</I><SUB>&#X3C3;</SUB>.<I>A</I>]] of nodes in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>
[[<I>Q</I><SUB>&#X3C3;</SUB>.<I>A</I>]] &#X2260; &#X2205;
Choose a topmost node <I>v</I>
Select the node <I>w</I> that is |<I>A</I>| levels atop of <I>v</I> in <I>T</I><SUB>&#X3A3;,&#X3D5;</SUB>
<I>w</I> is an ancestor of <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>
<I>w</I> 

&#X22A5; //<I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) does not exist.
-->
<A NAME="alg:wprima"><IMG SRC="images/algo-2.png"></A><BR><BR>
<!--
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Mini-tree corresponding to a non-implied key.</TD></TR>
</TABLE></DIV>
-->



Since [[<I>Q</I><SUB>&#X3C3;</SUB>.<I>A</I>]] can be evaluated in <FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7;|<I>Q</I><SUB>&#X3C3;</SUB>.<I>A</I>|) time, we can conclude from the
previous algorithm that <I>w</I><SUB>&#X3C3;</SUB><SUP><I>top</I></SUP>(<I>w</I><SUP>&#X2032;</SUP>) for a given <I>w</I><SUP>&#X2032;</SUP> can be 
determined in <FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7;|<I>Q</I><SUB>&#X3C3;</SUB>.<I>A</I>|) time.
Thus, it takes us <FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7;|&#X3C3;|) time
to determine all the witness edges arising from &#X3C3; that are needed for
deciding the reachability of <I>q</I><SUB>&#X3D5;</SUB> from <I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP> in
<I>G</I><SUB>&#X3A3;,&#X3D5;</SUB>. Finally, Step 2 of Algorithm&#XA0;<A HREF="#alg:implication">3</A> can be implemented by applying a
depth-first search algorithm to <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> with root
<I>q</I><SUB>&#X3D5;</SUB><SUP>&#X2032;</SUP>. This algorithm works in time linear in the number of edges
of <I>G</I><SUB>&#X3A3;,&#X3D5;</SUB> [<A HREF="#jungnickel:1999">17</A>]. 
Over all, our implementation can decide the 
implication problem &#X3A3;&#X22A8;&#X3D5; in
<FONT COLOR=red><I>O</I></FONT>(|&#X3D5;|&#XD7; (&#X2211;<SUB>&#X3C3;<SUB><I>i</I></SUB> &#X2208;
&#X3A3;</SUB>|&#X3C3;<SUB><I>i</I></SUB>| + |&#X3D5;|)) time.</P><!--TOC section Applying XML Key Reasoning to Document Validation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">5</A>&#XA0;&#XA0;Applying XML Key Reasoning to Document Validation</H2><!--SEC END --><P><A NAME="sec1:practical"></A><A NAME="sec2:validation"></A>

Fast algorithms for the validation of XML 
documents against keys are crucial to ensure the consistency and
semantic correctness of data stored in databases or exchanged between
applications [<A HREF="#Arenas:2008">18</A>]. 
In this section we explain how our implementation of the implication algorithm
for XML keys can be used to compute non-redundant cover sets of XML keys,
which in turn can be used to significantly speed up the process of XML document
validation against sets of XML keys. 
This 
is, up to our knowledge, the first time that the reasoning capabilities of XML
keys are used in this context. </P><P>



<B>Cover Sets for XML Keys</B>.<A NAME="sec2:covers"></A>
We define the concept of <EM>cover</EM> set of XML keys following the notion given in [<A HREF="#Maier:1980">19</A>, <A HREF="#Maier:1983">20</A>] for functional dependencies in the relational model.<BR><BR>

<B>Definition 2</B>.
Let &#X3A3;<SUP>*</SUP> denote the set of all XML keys implied by a given set &#X3A3;.
Two sets &#X3A3;<SUB>1</SUB> and &#X3A3;<SUB>2</SUB> of XML keys are <EM>equivalent</EM>, 
denoted by &#X3A3;<SUB>1</SUB> &#X2261; &#X3A3;<SUB>2</SUB>, 
if &#X3A3;<SUB>1</SUB><SUP>*</SUP> = &#X3A3;<SUB>2</SUB><SUP>*</SUP>. If &#X3A3;<SUB>1</SUB> and
&#X3A3;<SUB>2</SUB> are equivalent we call them a <EM>cover</EM> of one another. This
means that &#X3A3;<SUB>1</SUB> and &#X3A3;<SUB>2</SUB> imply exactly the same XML keys.
</P><P>For all cover &#X3A3;<SUB>2</SUB> of &#X3A3;<SUB>1</SUB>, if an XML tree <I>T</I><SUB><I>D</I></SUB> satisfies
&#X3A3;<SUB>2</SUB> (<I>T</I><SUB><I>D</I></SUB> &#X22A8; &#X3A3;<SUB>2</SUB>), then <I>T</I><SUB><I>D</I></SUB> &#X22A8; &#X3A3;<SUB>1</SUB> too. If
&#X3A3;<SUB>1</SUB> &#X2261; &#X3A3;<SUB>2</SUB>, then for each XML key &#X3C8; in &#X3A3;<SUB>1</SUB><SUP>*</SUP>,
&#X3A3;<SUB>2</SUB> &#X22A8; &#X3C8;, because &#X3A3;<SUB>2</SUB><SUP>*</SUP> = &#X3A3;<SUB>1</SUB><SUP>*</SUP>. In particular,
&#X3A3;<SUB>2</SUB> &#X22A8; &#X3C8; for each key &#X3C8; in &#X3A3;<SUB>1</SUB>.</P><P><BR>
	
<B>Definition 3</B>.
A set &#X3A3;<SUB>2</SUB> of XML keys is <EM>non-redundant</EM> if it is not equivalent
to any of its proper subsets. &#X3A3;<SUB>2</SUB> is a <EM>non-redundant cover</EM> for a
set &#X3A3;<SUB>1</SUB> of XML keys if &#X3A3;<SUB>2</SUB> is non-redundant and a cover for
&#X3A3;<SUB>1</SUB>.
</P><P>An important property is that a non-redundant cover set has in most cases
fewer keys that the original one (in the extreme case both sets are equal).
This can result in enormous time saving when validating an XML document
against a set of XML keys, as we will show in the experimental results.</P><P>A characterization of non-redundancy is that &#X3A3; is non-redundant if
there is no key &#X3C8; in &#X3A3; such that &#X3A3; &#X2212; {&#X3C8;} &#X22A8; &#X3C8;.
A key &#X3C8; &#X2208; &#X3A3; is called redundant if &#X3A3; &#X2212; {&#X3C8;} &#X22A8;
&#X3C8;. Thus, we propose Algorithm&#XA0;<A HREF="#alg:coverset">5</A> to compute, given
a set &#X3A3; of XML keys, a non-redundant cover &#X398; of &#X3A3;. <BR><BR>

<A NAME="alg:coverset"><IMG SRC="images/algo-3.png"></A><BR><BR>
<!--
(Non-redundant Cover for XML keys)
<A NAME="alg:coverset"></A>
[1]

finite set &#X3A3; of XML keys
a non-redundant cover for &#X3A3;
&#X398; = &#X3A3;;
each key &#X3C8; &#X2208; &#X3A3;
&#X398; &#X2212; {&#X3C8;} &#X22A8; &#X3C8;
&#X398; = &#X398; &#X2212; {&#X3C8;};


&#X398;;
-->

It is important to note that a set &#X3A3; can have more than one
non-redundant cover set and there can exist non-redundant cover sets that are
not included in &#X3A3;. </P><P>The complexity of Algorithm&#XA0;<A HREF="#alg:coverset">5</A> is determined by the complexity
of the implication algorithm which is executed once for every key in &#X3A3;.
Thus a non-redundant cover set for a set &#X3A3; of XML keys in <FONT COLOR=red><I>K</I></FONT> can be computed in <FONT COLOR=red>
<I>O</I></FONT>(|&#X3A3;| &#XD7; (<I>max</I>{|&#X3C8;|:&#X3C8; &#X2208; &#X3A3;})<SUP>2</SUP>) time.</P><!--TOC section Experimental Results-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">6</A>&#XA0;&#XA0;Experimental Results</H2><!--SEC END --><P> <A NAME="sec1:experiments"></A></P><P>In the following we present a performance analysis of the algorithms proposed
in this work. Up to our knowledge, this is the first time that the theory on automated reasoning
about XML keys is tested in practice. 
The running time results were obtained in an Intel Core 2 Duo 2.0 GHz machine, 
3GB RAM, and Linux kernel 2.6.32.</P><P>

<B>The Data Set</B>.<A NAME="dataset"></A>
We used a collection of large XML documents
from [<A HREF="#Repository">21</A>]. The collection consists of the following XML documents. A characterization
of the documents is shown in Table&#XA0;<A HREF="#table:benchmarks">1</A>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<EM>321gone.xml and yahoo.xml</EM>. Auction data converted to XML. 
</LI><LI CLASS="li-itemize"><EM>dblp.xml</EM>. Bibliographic
information on computer science. 
</LI><LI CLASS="li-itemize"><EM>nasa.xml</EM> Astronomical Data converted from legacy flat-file format into XML.
</LI><LI CLASS="li-itemize"><EM>SigmodRecord.xml</EM>. Index of articles from SIGMOD Record. 
</LI><LI CLASS="li-itemize"><EM>mondial-3.0.xml</EM>. World geographic database from several sources.
</LI></UL><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 1: XML Documents.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc ID</TD><TD VALIGN=top ALIGN=left NOWRAP>Document</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">No. of Elements</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">No. of Attributes</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Size</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Max. Depth</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Average Depth</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc1</TD><TD VALIGN=top ALIGN=left NOWRAP>321gone.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">311</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">0</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">23 KB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">5</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">3.76527</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc2</TD><TD VALIGN=top ALIGN=left NOWRAP>yahoo.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">342</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">0</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">24 KB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">5</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">3.76608</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc3</TD><TD VALIGN=top ALIGN=left NOWRAP>dblp.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">29,494</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">3,247</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">1.6 MB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">6</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">2.90228</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc4</TD><TD VALIGN=top ALIGN=left NOWRAP>nasa.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">476,646</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">56,317</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">23 MB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">8</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">5.58314</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc5</TD><TD VALIGN=top ALIGN=left NOWRAP>SigmodRecord.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">11,526</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">3,737</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">476 KB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">6</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">5.14107</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
Doc6</TD><TD VALIGN=top ALIGN=left NOWRAP>mondial-3.0.xml</TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">22,423</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">47,423</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">1 MB</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">5</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">3.59274</DIV></TD></TR>
</TABLE>
</DIV>
<A NAME="table:benchmarks"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>
We defined, for each document in the collection, a corresponding set of 5 to
10 appropriate (in the context of the document) XML keys.

Then, in order to test the scalability of the implication algorithm, we generated
large sets of XML keys in the following two systematic ways. 
Firstly, using the manually defined sets of XML keys 
as seeds,
we computed new implied keys by successively applying the inference rules from
the axiomatization of XML keys presented in [<A HREF="#Hartmann:2009">9</A>]. For
instance, by applying the interaction rule to (<I>listing</I>, (<I>auction</I>_<I>info</I>,
{<I>high</I>_<I>bidder</I>. <I>bidder</I>_<I>name</I>.<I>S</I>, <I>high</I>_<I>bidder</I>.<I>bidder</I>_<I>rating</I>. <I>S</I>})) and 
(<I>listing</I>.<I>auction</I>_<I>info</I>, (<I>high</I> _<I>bidder</I>, {<I>bidder</I>_<I>name</I>.<I>S</I>,
<I>bidder</I>_<I>rating</I>.<I>S</I>} )), we derived the implied key (<I>listing</I>, 
(<I>auction</I>_<I>info</I>.<I>high</I>_<I>bidder</I>, {<I>bidder</I>_<I>name</I>. <I>S</I>, <I>bidder</I>_<I>rating</I>.<I>S</I>})).
Each key generated by this method was added to the original set. We applied
the interaction, context-target, subnodes, context-path containment,
target-path containment, subnodes-epsilon and prefix-epsilon rules whenever possible, 
since those are the rules which can produce implied keys with corresponding
non trivial witness graphs (see the proof of Lemma&#XA0;3.6 in
[<A HREF="#Hartmann:2009">9</A>]). 
Secondly, we defined some non-implied (by the keys defined previously) XML keys.
We did that by taking non-implied XML keys &#X3D5;, building their
corresponding mini-trees <I>T</I><SUB>&#X3A3;, &#X3D5;</SUB>, adding several witness edges
to it while keeping <I>q</I><SUB>&#X3D5;</SUB> not reachable from <I>q</I>&#X2032;<SUB>&#X3D5;</SUB>, and finally
defining new non-implied XML keys corresponding to those witness edges. As an
example, let us take the mini-tree in Figure&#XA0;<A HREF="#fig:generating-tree">3</A> which
corresponds to the key &#X3D5; = (<I>conference</I>,
(<I>issue</I>._<SUP>*</SUP>.<I>articles</I>.<I>article</I>.<I>author</I>, {<I>first</I>.<I>S</I>, <I>last</I>.<I>S</I>})).
From the witness edges (a), (b) and&#XA0;(c), we obtained the keys,
(<I>conf</I>- <I>erence</I>.<I>issue</I>, (_<SUP>*</SUP>, { <I>articles</I>.<I>article</I>.<I>author</I>.<I>first</I>.<I>S</I>})),
(<I>conference</I>.<I>issue</I>._<SUP>*</SUP>, (<I>ar</I>- <I>ticles</I>.<I>article</I>, {<I>au</I>&#X2212; <I>thor</I>.<I>first</I>.<I>S</I>})) and
(<I>conference</I>.<I>issue</I>._<SUP>*</SUP>.<I>articles</I>, (<I>article</I>. <I>author</I> {<I>first</I>.<I>S</I>})),
respectively.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<A NAME="fig:generating-tree"><IMG SRC="images/figure-3.png"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Mini-tree corresponding to a non-implied key.</TD></TR>
</TABLE></DIV>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>This process gave us a robust collection of XML keys to thoroughly test
the performance of the implication algorithm. </P><P>
<B>Deciding Implication of XML Keys: Tests Results</B>.
The results regarding running times for deciding the implication of XML keys
are shown in Figures&#XA0;<A HREF="#fig:graph-imp-2">4(a)</A> and &#XA0;<A HREF="#fig:graph-imp-2">4(b)</A>. In both figures, 
the <I>x</I>-axis corresponds to the number of keys in &#X3A3;, and the <I>y</I>-axis 
corresponds to the <EM>average</EM> running time required to decide whether &#X3A3;
implies a given key &#X3D5;. More precisely, let <I>time</I>(&#X3A3;, &#X3D5;) be the
running time required to decide &#X3A3; &#X22A8; &#X3D5; and let &#X3A6; be a
set of XML keys such that &#X3A3; &#X2229; &#X3A6; = &#X2205;, the running time
shown in Figures&#XA0;<A HREF="#fig:graph-imp-2">4(a)</A> and&#XA0;<A HREF="#fig:graph-imp-2">4(b)</A>, corresponds
to (&#X2211;<SUB>&#X3D5;<SUB><I>i</I></SUB> &#X2208; &#X3A6;</SUB> <I>time</I>(&#X3A3;,
&#X3D5;<SUB><I>i</I></SUB>))/|&#X3A6;|. 
In our experiments the sets &#X3A6; were composed of 20
fixed XML keys each. 
We tested the scalability of the algorithm by adding, in each iteration, 5
new XML key to the corresponding &#X3A3; sets. 
The actual XML keys included in all these sets were created using the strategy
explained above. </P>
<P>We consider &#X3A3; sets composed by (i)&#XA0;only absolute keys 
(&#X201C;abs&#X201D;), (ii)&#XA0;only relative keys (&#X201C;rel&#X201D;) or (iii) both types of keys 
(&#X201C;mix&#X201D;). Given that an input key &#X3D5; can be either absolute or relative, 
we have a total of six test cases.
The results obtained in these experiments are summarized in Figure&#XA0;<A HREF="#fig:graph-imp-2">4(a)</A>. 
For a small set &#X3A3; with about 5 XML keys, the execution takes 
0.2ms in average, whereas for a large set of about 100 XML keys, the execution
takes 1.7ms in average. This indicates that our implementation of the implication algorithm is 
practically efficient and scales well regardless of the type of XML keys
considered. </P><P>Note that the resulting running time is slightly lower when &#X3D5; is an 
absolute key and &#X3A3; is composed by either absolute or relative keys. 
This is mainly due to the fact that <I>Q</I><SUB>&#X3D5;</SUB> = &#X3B5;, which means
that the construction of the mini-tree involves less steps and that the <I>q</I><SUB>&#X3D5;</SUB> node corresponds to the root node, 
making it unnecessary to perform a search for such node.
On the other hand, the performance shown by the &#X201C;abs-rel&#X201D; curve in Figure&#XA0;<A HREF="#fig:graph-imp-2">4(a)</A> 
is slightly degraded due to the fact that, in general, the algorithm needs to
traverse more nodes to determine whether <I>q</I><SUB>&#X3D5;</SUB> is reachable from
<I>q</I>&#X2032;<SUB>&#X3D5;</SUB>. This is consistent with the way in which the witness graphs are
defined. </P><P>To isolate the effect of wildcards in the performance of the algorithm, 
we duplicated the number of wildcards in the keys 
of the test case &#X201C;mix-rel&#X201D;, replacing some of the 
labels in the context and target paths of those keys by the variable length
wildcard. 
Figure&#XA0;<A HREF="#fig:graph-imp-2">4(b)</A> shows the running times for 
the original set of keys (curve &#X201C;mix-rel&#X201D;) and the set with increased 
number of wildcards (curve &#X201C;wildcard&#X201D;). The results show that the 
presence of wildcards in the path expressions increases the 
running time for the test sets with large number of keys, but such increase is
not significant in practice.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<A NAME="fig:graph-imp-2"><IMG SRC="images/figure-4.png"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4: Performance of the Algorithm for the Implication of XML Keys.</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>

<B>Document Validation: Tests Results</B>.
<A NAME="sec2:validation-experiments"></A>
We use the same data set as before. 
The aim is to determine the viability of computing non-redundant cover
sets to speed up the validation of XML documents against XML keys.
By validating an XML document against a
set of XML key, we refer to the task of checking, for every XML key in the
set, whether the document satisfies such key. </P><P>To validates XML keys, we use a naive algorithm that parses the XML
document into a DOM tree and then evaluates the XML keys on the resulting tree, 
by using XPath queries to express their context, target and key paths. 
We do need to use sophisticated validation algorithms such as
[<A HREF="#Chen:2002">12</A>, <A HREF="#Abrao:2004">13</A>, <A HREF="#Liu:2005">14</A>], since the proposed optimization based in
cover sets is independent of the particular algorithm used for XML key validation. </P><P>The results (in milliseconds (ms)) obtained from the computation of non-redundant
cover sets is summarized in Figure&#XA0;5 (a). We emphasize that 
the behavior of the Algorithm&#XA0;<A HREF="#alg:coverset">5</A> is linear in practice. 
For example, for a set of 146 keys, calculating a non-redundant cover set 
takes around 155ms. A total of 102 keys are discarded reducing the set to 44 keys. 
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>
</TD><TD ALIGN=center NOWRAP>
<A NAME="tabla:covers"><IMG SRC="images/figure-5.png"></A></TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5: Non-redundant Cover Sets of XML keys and Validation of XML Documents</TD></TR>
</TABLE></DIV>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Figure&#XA0;5 (b) shows the optimization achieved by pre-calculating non-redundant cover sets 
during the validation process of the documents in
Table&#XA0;<A HREF="#table:benchmarks">1</A>. The results indicate that 
the running time required to compute a non-redundant cover 
set is just a tiny fraction of the overall running time required 
to validate a single XML document against a key. 
Note that in most cases the
validation time can be significantly reduced by pre-computing the
non-redundant covers. This can be clearly observed 
in the case of the DBLP document (&#X2019;Doc3&#X2019;) and Nasa document (&#X2019;Doc4&#X2019;). In these
cases the running time of the validation against the original set of XML keys
is approximately 63 times greater than the running time of the validation
against its non-redundant cover-set. </P><!--TOC section Conclusion-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">7</A>&#XA0;&#XA0;Conclusion</H2><!--SEC END --><P><A NAME="sec1:conclusions"></A>
Our research was motivated by two objectives. Firstly, we
wanted to demonstrate that there are expressive classes of XML keys that are
not only tractable in theory but can be reasoned about efficiently in
practice. For that we studied a fragment of XML keys as originally introduced
by Buneman et al.&#XA0;[<A HREF="#Buneman:2002">3</A>, <A HREF="#Buneman:2003">4</A>], namely the class
<FONT COLOR=red><I>K</I></FONT> of XML keys with nonempty set of simple key paths. For
these keys it was known that their implication problem can be decided in
quadratic time in theory&#XA0;[<A HREF="#Hartmann:2009">9</A>]. Here we have presented an
efficient implementation thereof, and our experiments show that it also runs
fast in practice and scales well.</P><P>Secondly, we wanted to show that our observations on the problem of deciding
implication is not only of interest for the problem itself but has immediate
consequences for other perennial tasks in XML database management. As an
example we study the problem of validating an XML document against a set of
XML keys. We have presented an optimization method for this validation that
computes a non-redundant cover for the set of XML keys given as input so that
satisfaction only needs to be checked for the keys in this cover. This can
reduce the number of keys significantly, and our experiments show that
enormous time savings can be achieved in practice. This holds true even though
the validation procedure is able to decide value equality among element nodes
with complex content as this is required for the XML keys studied here (and
distinguishes them from the keys defined in XML Schema). 
This illustrates the advantage of having efficient
reasoning capabilities at hand for integrity constraints.</P><P>We would like to emphasize that the use of non-redundant covers does not depend on
the particular choice of the XML fragment but can be tailored to any class of
XML keys for which the implication problem can be solved efficiently. 
We plan to extend out studies to other expressive classes of XML keys
and related constraints. In a first step we will consider keys that allow
single label wildcards in their path expressions as studied from a theoretical
perspective in [<A HREF="#Ferrarotti:2010">11</A>].</P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="xml:2006"><FONT COLOR=purple>[1]</FONT></A></DT><DD CLASS="dd-thebibliography">
Bray, T., Paoli, J., Sperberg-McQueen, C.M., Maler, E., Yergeau, F.:
XML 1.0 (fourth edition) W3C
recommendation.
http://www.w3.org/TR/xml (2006)</DD><DT CLASS="dt-thebibliography"><A NAME="Hartmann:2008a"><FONT COLOR=purple>[2]</FONT></A></DT><DD CLASS="dd-thebibliography">
Hartmann, S., Koehler, H., Link, S., Trinh, T., Wang, J.:
On the notion of an XML key.
In: SDKB 2007, Vol. 4925 of LNCS, Springer (2007) 103&#X2013;112</DD><DT CLASS="dt-thebibliography"><A NAME="Buneman:2002"><FONT COLOR=purple>[3]</FONT></A></DT><DD CLASS="dd-thebibliography">
Buneman, P., Davidson, S., Fan, W., Hara, C., Tan, W.:
Keys for XML.
Computer Networks <B>39</B>(5) (2002) 473&#X2013;487</DD><DT CLASS="dt-thebibliography"><A NAME="Buneman:2003"><FONT COLOR=purple>[4]</FONT></A></DT><DD CLASS="dd-thebibliography">
Buneman, P., Davidson, S., Fan, W., Hara, C., Tan, W.:
Reasoning about keys for XML.
Inf. Syst. <B>28</B>(8) (2003) 1037&#X2013;1063</DD><DT CLASS="dt-thebibliography"><A NAME="dom:1998"><FONT COLOR=purple>[5]</FONT></A></DT><DD CLASS="dd-thebibliography">
Apparao et al, V.:
Document object model (DOM) level 1 specification, W3C
recommendation.
http://www.w3.org/TR/REC-DOM-Level-1/ (1998)</DD><DT CLASS="dt-thebibliography"><A NAME="xpath:1999"><FONT COLOR=purple>[6]</FONT></A></DT><DD CLASS="dd-thebibliography">
Clark, J., DeRose, S.:
XML path language (XPath) version 1.0, W3C recommendation.
http://www.w3.org/TR/xpath (1999)</DD><DT CLASS="dt-thebibliography"><A NAME="xmlschema:2004"><FONT COLOR=purple>[7]</FONT></A></DT><DD CLASS="dd-thebibliography">
Thompson, H., Beech, D., Maloney, M., Mendelsohn, N.:
XML Schema Part 1,
W3C Recommendation.
http://www.w3.org/TR/xmlschema-1/ (2004)</DD><DT CLASS="dt-thebibliography"><A NAME="arenas:2002"><FONT COLOR=purple>[8]</FONT></A></DT><DD CLASS="dd-thebibliography">
Arenas, M., Fan, W., Libkin, L.:
What&#X2019;s hard about XML Schema constraints?
In: DEXA 2002, Vol. 2453 of LNCS,
Springer (2002) 269&#X2013;278</DD><DT CLASS="dt-thebibliography"><A NAME="Hartmann:2009"><FONT COLOR=purple>[9]</FONT></A></DT><DD CLASS="dd-thebibliography">
Hartmann, S., Link, S.:
Efficient reasoning about a robust XML key fragment.
ACM Trans. Database Syst. <B>34</B>(2) (2009)</DD><DT CLASS="dt-thebibliography"><A NAME="Hartmann:2009b"><FONT COLOR=purple>[10]</FONT></A></DT><DD CLASS="dd-thebibliography">
Hartmann, S., Link, S.:
Expressive, yet tractable XML keys.
In: EDBT 2009, Vol. 360 of ACM International Conference Proceeding Series.,
ACM (2009) 357&#X2013;367</DD><DT CLASS="dt-thebibliography"><A NAME="Ferrarotti:2010"><FONT COLOR=purple>[11]</FONT></A></DT><DD CLASS="dd-thebibliography">
Ferrarotti, F., Hartmann, S., Link, S., Wang, J.:
Promoting the semantic capability of XML keys.
In: XSym 2010, Vol. 6309
of LNCS, Springer (2010) 144&#X2013;153</DD><DT CLASS="dt-thebibliography"><A NAME="Chen:2002"><FONT COLOR=purple>[12]</FONT></A></DT><DD CLASS="dd-thebibliography">
Chen, Y., Davidson, S., Zheng, Y.:
Xkvalidator: a constraint validator for XML.
In: CIKM 2002, ACM (2002) 446&#X2013;452</DD><DT CLASS="dt-thebibliography"><A NAME="Abrao:2004"><FONT COLOR=purple>[13]</FONT></A></DT><DD CLASS="dd-thebibliography">
Abr&#XE3;o, M., Bouchou, B., Halfeld Ferrari Alves, M., Laurent, D., Musicante, M.:
Incremental constraint checking for XML documents.
In: XSym 2004, Vol. 3186 of LNCS, Springer (2004) 112&#X2013;127</DD><DT CLASS="dt-thebibliography"><A NAME="Liu:2005"><FONT COLOR=purple>[14]</FONT></A></DT><DD CLASS="dd-thebibliography">
Liu, Y., Yang, D., Tang, S., Wang, T., Gao, J.:
Validating key constraints over XML document using XPath and
structure checking.
Future Generation Comp. Syst. <B>21</B>(4) (2005) 583&#X2013;595</DD><DT CLASS="dt-thebibliography"><A NAME="gottlob:2005"><FONT COLOR=purple>[15]</FONT></A></DT><DD CLASS="dd-thebibliography">
Gottlob, G., Koch, C., Pichler, R.:
Efficient algorithms for processing XPath queries.
Trans. Database Syst. <B>30</B>(2) (2005) 444&#X2013;491</DD><DT CLASS="dt-thebibliography"><A NAME="Aho:1983"><FONT COLOR=purple>[16]</FONT></A></DT><DD CLASS="dd-thebibliography">
Aho, A., Ullman, J., Hopcroft, J.:
Data structures and algorithms.
Addison-Wesley (1983)</DD><DT CLASS="dt-thebibliography"><A NAME="jungnickel:1999"><FONT COLOR=purple>[17]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jungnickel, D.:
Graphs, Networks and Algorithms.
Springer (1999)</DD><DT CLASS="dt-thebibliography"><A NAME="Arenas:2008"><FONT COLOR=purple>[18]</FONT></A></DT><DD CLASS="dd-thebibliography">
Arenas, M., Libkin, L.:
XML data exchange: Consistency and query answering.
J. ACM <B>55</B> (May 2008) 7:1&#X2013;7:72</DD><DT CLASS="dt-thebibliography"><A NAME="Maier:1980"><FONT COLOR=purple>[19]</FONT></A></DT><DD CLASS="dd-thebibliography">
Maier, D.:
Minimum Covers in the Relational Database Model.
J. ACM <B>27</B> (October 1980) 664&#X2013;674</DD><DT CLASS="dt-thebibliography"><A NAME="Maier:1983"><FONT COLOR=purple>[20]</FONT></A></DT><DD CLASS="dd-thebibliography">
Maier, D.:
The Theory of Relational Databases.
<TT>http://web.cecs.pdx.edu/~maier/TheoryBook/TRD.html</TT> (1983)</DD><DT CLASS="dt-thebibliography"><A NAME="Repository"><FONT COLOR=purple>[21]</FONT></A></DT><DD CLASS="dd-thebibliography">
Suciu, D.:
XML Data Repository, University of Washington.

<TT>http://www.cs.washington.edu/research/xmldatasets/www/repository.html</TT>
(2002)</DD></DL><!--BEGIN NOTES document-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">*</A></DT><DD CLASS="dd-thefootnotes">The contribution of this author was based on
his Master&#X2019;s thesis, which was supported by grants from the
University of Santiago de Chile and Yahoo! Labs.
</DD></DL>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
